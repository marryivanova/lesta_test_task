# lesta_test_task
test_task

# lesta_test_task
test_task

Вопрос №1

На языке Python написать алгоритм (функцию) определения четности целого числа, который будет аналогичен нижеприведенному по функциональности, но отличен по своей сути. Объяснить плюсы и минусы обеих реализаций. 

Пример: 
```
def isEven(value):
      return value % 2 == 0 
```

Плюсы:
+ Код короче и более компактный;
+ Не требуется дополнительных проверок или условий, просто вызывается функция isEven с числом в качестве аргумента;
+ Обрабатывает 0 - True.

Минусы:
- Отсутствие обработки ошибок.Не содержат обработки ошибок, например, пользователь может ввести нечисловое значение или отрицательное число, что может привести к неожиданным результатам.

Ответ: Для реализации можно использовать битовые операции -> & (AND)

```
  def is_even(value):
    return (value & 1) == 0
```

Суть: Логика работы: при сравнении двух бит (в одном и том же разряде) & выдает 1 (то есть бит будет скопирован), если бит есть в обоих сравниваемых операндах, и 0, если это условие не выполняется (то есть бит отсутствует хотя бы в одном из операндов)

Материал для реализиции тут: https://prog.sch57.ru/listki/2018-2019/math/08/bitwise.pdf 

Плюсы данной реализации:
- Более эффективное выполнение для большинства целых чисел, так как битовая операция выполняется быстрее операции взятия остатка.


Минусы данной реализации:
- Битовые операторы имеют более низкий приоритет по сравнению с арифметическими операторами;
- Может быть менее интуивной для некоторых разработчиков из-за использования битовых операций.


Вопрос №2

На языке Python написать минимум по 2 класса реализовывающих циклический буфер FIFO. Объяснить плюсы и минусы каждой реализации.

1 класс:

```
class MyCircularQueue():

    def __init__(self, n):
        self.n = n
        self.queue = [None] * n
        self.head = self.tail = -1

    # Добавляем элемент в круговую очередь
    def enqueue(self, data):

        if ((self.tail + 1) % self.n == self.head):
            print("Круговая очередь заполнена\n")

        elif (self.head == -1):
            self.head = 0
            self.tail = 0
            self.queue[self.tail] = data
        else:
            self.tail = (self.tail + 1) % self.n
            self.queue[self.tail] = data

    # Удаляем элемент из очереди
    def dequeue(self):
        if (self.head == -1):
            print("Круговая очередь пуста\n")

        elif (self.head == self.tail):
            temp = self.queue[self.head]
            self.head = -1
            self.tail = -1
            return temp
        else:
            temp = self.queue[self.head]
            self.head = (self.head + 1) % self.n
            return temp

    def printCQueue(self):
        if(self.head == -1):
            print("В круговой очереди нет элементов")

        elif (self.tail >= self.head):
            for i in range(self.head, self.tail + 1):
                print(self.queue[i], end=" ")
            print()
        else:
            for i in range(self.head, self.n):
                print(self.queue[i], end=" ")
            for i in range(0, self.tail + 1):
                print(self.queue[i], end=" ")
            print()


# Инициализируется и вызывается объект MyCircularQueue следующим образом:
obj = MyCircularQueue(5)
obj.enqueue(1)
obj.enqueue(2)
obj.enqueue(3)
obj.enqueue(4)
obj.enqueue(5)
print("Исходная очеред")
obj.printCQueue()

obj.dequeue()
print("После удаления элемента из очереди")
obj.printCQueue()
```
Суть реализации: Круговая очередь -> Круговые очереди позволяют избежать пустых пространств, которые появляются в обычных очередях, реализованных с помощью массивов;
В основе лежит: принципу циклического инкрементирования

Плюсы:
+ Эффективное использование памяти: при использовании круговой очереди в сочетании с массивамидается избежать пустых пространств, которые появляются в обычных очередях на основе массивов. Это позволяет эффективнее использовать доступное пространство.
  
­+  Постоянная временная сложность операций вставки и удаления: благодаря принципу циклического инкрементирования возможно выполнение операций вставки и удаления элементов за постоянное время O(1), что делает циклический буфер оба быстрым и эффективным.
­
+ Простота реализации: реализация циклического буфера обмена с использованием круговой очереди и массивов обычно является относительно простой и понной, что упрощает разработку и поддержку такой структуры данных.


Минусы:
+ Фиксированный размер: реализация санием массивов подразумевает фиксированный размер буфера, что может привести к ограничению количества элементов, которые можно добавить в буфер. При неудачном расчёте размера буфера возникает р переполнения или неэффективного использования памяти.

+ Сложности при расширении: изменение размера циклического буфера после создания может быть нетривиальной задачей. Это может вызвать необходимость копирования данных в новую структуру с нужным размером.

+ Сложности при работе с произвольным доступом к элементам: циклический буфер обмена не предоставляет эфективного доступа к элементам по произвольному индексу из-за своей специфической структуры, что может усложнить определенные типы операций.

2 Класс:

```
class Node:
    def __init__(self, key, data):
        self.key = key
        self.data = data
        self.next = None


class LinkedList:
    def __init__(self):
        self.head = None

    def is_empty(self):
        return self.head is None

    def length(self):
        length = 0

        if self.head is None:
            return length

        current = self.head
        length = 1
        while current.next != self.head and current.next != self.head.next:
            length += 1
            current = current.next

        return length

    def insert_first(self, key, data):
        new_node = Node(key, data)

        if self.is_empty():
            self.head = new_node
            new_node.next = self.head
        else:
            current = self.head
            while current.next != self.head:
                current = current.next
            current.next = new_node
            new_node.next = self.head
            self.head = new_node

    def delete_first(self):
        if self.is_empty():
            return None

        temp = self.head
        if self.head.next == self.head:
            self.head = None
        else:
            current = self.head
            while current.next != self.head:
                current = current.next
            current.next = self.head.next
            self.head = self.head.next

        return temp

    def print_list(self):
        if self.is_empty():
            print("[]")
            return

        current = self.head
        print("[", end=" ")
        while True:
            print(f"({current.key},{current.data})", end=" ")
            current = current.next
            if current == self.head:
                break
        print("]")


# Создание и использование связанного списка
linked_list = LinkedList()
linked_list.insert_first(1, 10)
linked_list.insert_first(2, 20)
linked_list.insert_first(3, 30)
linked_list.insert_first(4, 1)
linked_list.insert_first(5, 40)
linked_list.insert_first(6, 56)

print("Original List: ")
linked_list.print_list()

while not linked_list.is_empty():
    temp = linked_list.delete_first()
    print("\nDeleted value:", f"({temp.key},{temp.data})", end=" ")

print("\nList after deleting all items: ")
linked_list.print_list()
```
Суть: Использовался связный список для реализации 
Кольцевой (циклический, замкнутый) связный список — это разновидность связного списка, при которой первый элемент указывает на последний, а последний — на первый. Кольцевой (циклический, замкнутый) связный список можно сделать как из односвязного (однонаправленного), так и из двусвязного (двунаправленного) списка.

Он создает два класса: Node (узел) и LinkedList (связанный список). Класс Node используется для создания узлов списка, а класс LinkedList представляет собой основной функционал списка, такой как вставка элемента в начало списка, удаление первого элемента списка и печать списка.
­
Плюсы:

+ Реализуетиклическую односвязную реализацию связанного списка, что может быть полезным в определенных сценариях.
+ Методы вставки, удаления и печи списка реализованы корректно и эффективно.
­
Минусы:
- Использование дополнительной памяти: Связанный список требует допительной памяти для хранения указателей на следующий и предыдущий элементы, что может быть излишним для циклического буфера обмена, особенно при больших объемах данных.
- Сложность доступа к элементам Для доступа к конкретному элементу в связанном списке требуется перебирать список от начала до нужного элемента, что может быть неэффективно для операций вставки, удаления или поиска элементов

  
Вопрос №3

На языке Python предложить алгоритм, который быстрее всего (по процессорным тикам) отсортирует данный ей массив чисел. Массив может быть любого размера со случайным порядком чисел (в том числе и отсортированным). Объяснить, почему вы считаете, что функция соответствует заданным критериям.


Можно предположить 2 варианта: Один, наверное, то что и нужно предложить, обычно про них говорят на первых курсах в университете - и это Быстрая сортировка. Почему быстра: Почему я считаю QuickSort самым быстрым алгоритмом для сортировки в данном случае?

    •	QuickSort имеет среднюю временную сложность O(n log n) и лучшую временную сложность O(n log n) в среднем случае.
    •	Алгоритм эффективно использует память, не требуя дополнительного выделения массивов.
    •	Он хорошо справляется с массивами любого размера, включая случайные и уже отсортированные массивы.
    •	QuickSort является одним из самых распространенных и широко используемых алгоритмов сортировки, и его реализация в Python довольно эффективна.

Я бы хотела отметить, что, конечно, все зависит от исходных данных. Оптимальность алгоритма тесно зависит от типа списков/массивов, которые вы собираетесь сортировать, и даже от модели ЭВМ. Чем больше информации в вашем распоряжении, тем более точным будет выбор. При очень слабых предположениях о факторах оптимальной сложностью худшего случая может быть О(n!). Данный ответ касается только сложностей. Фактическое время выполнения алгоритмов зависит от огромного количества факторов.
