# lesta_test_task
test_task

# lesta_test_task
test_task

Вопрос №1

На языке Python написать алгоритм (функцию) определения четности целого числа, который будет аналогичен нижеприведенному по функциональности, но отличен по своей сути. Объяснить плюсы и минусы обеих реализаций. 

Пример: 
```
def isEven(value):
      return value % 2 == 0 
```

Плюсы:
+ Код короче и более компактный;
+ Не требуется дополнительных проверок или условий, просто вызывается функция isEven с числом в качестве аргумента;
+ Обрабатывает 0 - True.

Минусы:
- Отсутствие обработки ошибок.Не содержат обработки ошибок, например, пользователь может ввести нечисловое значение или отрицательное число, что может привести к неожиданным результатам.

Ответ: Для реализации можно использовать битовые операции -> & (AND)

```
  def is_even(value):
    return (value & 1) == 0
```

Суть: Логика работы: при сравнении двух бит (в одном и том же разряде) & выдает 1 (то есть бит будет скопирован), если бит есть в обоих сравниваемых операндах, и 0, если это условие не выполняется (то есть бит отсутствует хотя бы в одном из операндов)

Материал для реализиции тут: https://prog.sch57.ru/listki/2018-2019/math/08/bitwise.pdf 

Плюсы данной реализации:
- Более эффективное выполнение для большинства целых чисел, так как битовая операция выполняется быстрее операции взятия остатка.


Минусы данной реализации:
- Битовые операторы имеют более низкий приоритет по сравнению с арифметическими операторами;
- Может быть менее интуивной для некоторых разработчиков из-за использования битовых операций.


Вопрос №2

На языке Python написать минимум по 2 класса реализовывающих циклический буфер FIFO. Объяснить плюсы и минусы каждой реализации.

1 класс:

```
class MyCircularQueue():

    def __init__(self, n):
        self.n = n
        self.queue = [None] * n
        self.head = self.tail = -1

    # Добавляем элемент в круговую очередь
    def enqueue(self, data):

        if ((self.tail + 1) % self.n == self.head):
            print("Круговая очередь заполнена\n")

        elif (self.head == -1):
            self.head = 0
            self.tail = 0
            self.queue[self.tail] = data
        else:
            self.tail = (self.tail + 1) % self.n
            self.queue[self.tail] = data

    # Удаляем элемент из очереди
    def dequeue(self):
        if (self.head == -1):
            print("Круговая очередь пуста\n")

        elif (self.head == self.tail):
            temp = self.queue[self.head]
            self.head = -1
            self.tail = -1
            return temp
        else:
            temp = self.queue[self.head]
            self.head = (self.head + 1) % self.n
            return temp

    def printCQueue(self):
        if(self.head == -1):
            print("В круговой очереди нет элементов")

        elif (self.tail >= self.head):
            for i in range(self.head, self.tail + 1):
                print(self.queue[i], end=" ")
            print()
        else:
            for i in range(self.head, self.n):
                print(self.queue[i], end=" ")
            for i in range(0, self.tail + 1):
                print(self.queue[i], end=" ")
            print()


# Инициализируется и вызывается объект MyCircularQueue следующим образом:
obj = MyCircularQueue(5)
obj.enqueue(1)
obj.enqueue(2)
obj.enqueue(3)
obj.enqueue(4)
obj.enqueue(5)
print("Исходная очеред")
obj.printCQueue()

obj.dequeue()
print("После удаления элемента из очереди")
obj.printCQueue()
```
Суть реализации: Круговая очередь -> Круговые очереди позволяют избежать пустых пространств, которые появляются в обычных очередях, реализованных с помощью массивов;
В основе лежит: принципу циклического инкрементирования

Плюсы:
+ Эффективное использование памяти: при использовании круговой очереди в сочетании с массивамидается избежать пустых пространств, которые появляются в обычных очередях на основе массивов. Это позволяет эффективнее использовать доступное пространство.
  
­+  Постоянная временная сложность операций вставки и удаления: благодаря принципу циклического инкрементирования возможно выполнение операций вставки и удаления элементов за постоянное время O(1), что делает циклический буфер оба быстрым и эффективным.
­
+ Простота реализации: реализация циклического буфера обмена с использованием круговой очереди и массивов обычно является относительно простой и понной, что упрощает разработку и поддержку такой структуры данных.


Минусы:
+ Фиксированный размер: реализация санием массивов подразумевает фиксированный размер буфера, что может привести к ограничению количества элементов, которые можно добавить в буфер. При неудачном расчёте размера буфера возникает р переполнения или неэффективного использования памяти.

+ Сложности при расширении: изменение размера циклического буфера после создания может быть нетривиальной задачей. Это может вызвать необходимость копирования данных в новую структуру с нужным размером.

+ Сложности при работе с произвольным доступом к элементам: циклический буфер обмена не предоставляет эфективного доступа к элементам по произвольному индексу из-за своей специфической структуры, что может усложнить определенные типы операций.

2 Класс:




Вопрос №3

На языке Python предложить алгоритм, который быстрее всего (по процессорным тикам) отсортирует данный ей массив чисел. Массив может быть любого размера со случайным порядком чисел (в том числе и отсортированным). Объяснить, почему вы считаете, что функция соответствует заданным критериям.
Можно предположить 2 варианта: Один, наверное, то что и нужно предложить, обычно про них говорят на первых курсах в университете - и это Быстрая сортировка. Почему быстра: Почему я считаю QuickSort самым быстрым алгоритмом для сортировки в данном случае?

    •	QuickSort имеет среднюю временную сложность O(n log n) и лучшую временную сложность O(n log n) в среднем случае.
    •	Алгоритм эффективно использует память, не требуя дополнительного выделения массивов.
    •	Он хорошо справляется с массивами любого размера, включая случайные и уже отсортированные массивы.
    •	QuickSort является одним из самых распространенных и широко используемых алгоритмов сортировки, и его реализация в Python довольно эффективна.

Я бы хотела отметить, что, конечно, все зависит от исходных данных. Оптимальность алгоритма тесно зависит от типа списков/массивов, которые вы собираетесь сортировать, и даже от модели ЭВМ. Чем больше информации в вашем распоряжении, тем более точным будет выбор. При очень слабых предположениях о факторах оптимальной сложностью худшего случая может быть О(n!). Данный ответ касается только сложностей. Фактическое время выполнения алгоритмов зависит от огромного количества факторов.
